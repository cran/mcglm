<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Abstract</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<hr/>

<p>To install the stable version of <a href="http://github.com/wbonat/mcglm"><code>mcglm</code></a>, use
<code>devtools::install_git()</code>. For more information, visit <a href="http://github.com/wbonat/mcglm/blob/master/README.md">mcglm/README</a>.</p>

<pre><code class="r">library(devtools)
install_git(&quot;wbonat/mcglm&quot;)
</code></pre>

<pre><code class="r">library(mcglm)
packageVersion(&quot;mcglm&quot;)
</code></pre>

<h5>Abstract</h5>

<p>The <code>mcglm</code> package implements the multivariate covariance generalized
linear models (McGLMs) proposed by Bonat and J$\o$rgensen (2016).
The core fit function <code>mcglm</code> is employed for fitting a set of models. 
In this introductory vignette we restrict ourselves to model 
independent data, although a simple model for longitudinal data analysis
in the Gaussian case is also presented. We present models to deal with
continuous, binomial/bounded and count univariate response variables.
We explore the specification of different link, variance and covariance
functions.</p>

<hr/>

<h2>Regression models for continuous data</h2>

<p>Consider a simple regression model, for univariate and independent 
Gaussian data:
\[Y \sim N(X \beta, \tau_0 Z_0).\]</p>

<pre><code class="r"># Loading extra packages
require(mcglm)
require(Matrix)
require(mvtnorm)
require(tweedie)

# Setting the seed
set.seed(2503)

# Fixed component
x1 &lt;- seq(-1,1, l = 100)
X &lt;- model.matrix(~ x1)
mu1 &lt;- mcglm::mc_link_function(beta = c(1,0.8), X = X, offset = NULL, 
                        link = &quot;identity&quot;)
# Random component
y1 &lt;- rnorm(100, mu1$mu, sd = 0.5)

# Data structure
data &lt;- data.frame(&quot;y1&quot; = y1, &quot;x1&quot; = x1)

# Matrix linear predictor
Z0 &lt;- mc_id(data)

# Fit
fit1.id &lt;- mcglm(linear_pred = c(y1 ~ x1), 
                 matrix_pred = list(Z0),
                 data = data)
</code></pre>

<pre><code>## Automatic initial values selected.
</code></pre>

<p>The <code>mcglm</code> package offers the following set of <code>S3-methods</code> for
model summarize.</p>

<pre><code class="r">print(methods(class = &quot;mcglm&quot;))
</code></pre>

<pre><code>## [1] anova     coef      confint   fitted    plot      print    
## [7] residuals summary   vcov     
## see &#39;?methods&#39; for accessing help and source code
</code></pre>

<p>The traditional <code>summary</code> for a fitted model can be obtained by</p>

<pre><code class="r">summary(fit1.id)
</code></pre>

<pre><code>## Call: y1 ~ x1
## 
## Link function: identity
## Variance function: constant
## Covariance function: identity
## Regression:
##             Estimates  Std.error  Z value     Pr(&gt;|z|)
## (Intercept) 1.0029066 0.05383753 18.62839 1.891184e-77
## x1          0.9488496 0.09232145 10.27767 8.884812e-25
## 
## Dispersion:
##   Estimates  Std.error  Z value     Pr(&gt;|z|)
## 1 0.2898479 0.04137255 7.005803 2.455725e-12
## 
## Algorithm: chaser
## Correction: TRUE
## Number iterations: 2
</code></pre>

<p>The function <code>summary.mcglm</code> was designed to be similar to the native
<code>summary</code> functions for the classes <code>lm</code> and <code>glm</code>. Extra features were
included to describe the dispersion structure. The mean formula call,
along with the the <code>link</code>, <code>variance</code> and <code>covariance</code> functions are
presented. The parameter estimates are presented in two blocks,
the first presents the regression estimates while the second presents
the dispersion estimates. In both cases the parameter estimates are
summarized by point estimates, standard errors, Z-values and p-values associated
with the Wald test whose null hypothesis is defined as \(\beta = 0\) and
\(\tau = 0\) for the mean and dispersion structures, respectively.
Finally, the selected algorithm, if the correction term is employed or 
not and the number of iterations is printed.</p>

<p>The same linear regresion model can be fitted by using a 
different covariance link function, for example the inverse covariance 
link function.</p>

<pre><code class="r"># Fit using inverse covariance link function 
fit1.inv &lt;- mcglm(linear_pred = c(y1 ~ x1), 
                  matrix_pred = list(Z0),
                  covariance = &quot;inverse&quot;, data = data)
</code></pre>

<pre><code>## Automatic initial values selected.
</code></pre>

<p>Furthermore, we can use a less conventional covariance link function,
as the exponential-matrix. </p>

<pre><code class="r"># Fit using expm covariance link function
fit1.expm &lt;- mcglm(linear_pred = c(y1 ~ x1), 
                   matrix_pred = list(Z0),
                   covariance = &quot;expm&quot;, data = data)
</code></pre>

<pre><code>## Automatic initial values selected.
</code></pre>

<p>The function <code>mcglm</code> returns an object of mcglm class, for which we can
use the method <code>coef</code> to extract the parameters estimates.</p>

<pre><code class="r"># Comparing estimates using different covariance link functions
cbind(coef(fit1.id)$Estimates,
      coef(fit1.inv)$Estimates,
      coef(fit1.expm)$Estimates)
</code></pre>

<pre><code>##           [,1]      [,2]       [,3]
## [1,] 1.0029066 1.0029066  1.0029066
## [2,] 0.9488496 0.9488496  0.9488496
## [3,] 0.2898479 3.4500851 -1.2383989
</code></pre>

<pre><code class="r"># Applying the inverse transformation
c(coef(fit1.id)$Estimates[3],
  1/coef(fit1.inv)$Estimates[3],
  exp(coef(fit1.expm)$Estimates[3]))
</code></pre>

<pre><code>## [1] 0.2898479 0.2898479 0.2898479
</code></pre>

<p>Consider an extension of the linear regression models to deal with 
heteroscedasticity:</p>

<p>\[ Y \sim N(X \beta, \tau_0 Z_0 + \tau_1 Z_1),\]
where \(Z_0\) is a identity matrix and \(Z_1\) is a diagonal matrix whose
elements are given by the values of a known covariate. Such a model,
can be fitted easily using the <code>mcglm</code> package.</p>

<pre><code class="r"># Mean model
set.seed(1811)
x1 &lt;- seq(-1,1, l = 100)
X &lt;- model.matrix(~ x1)
mu1 &lt;- mcglm::mc_link_function(beta = c(1,0.8), X = X, offset = NULL, 
                        link = &quot;identity&quot;)
z1 &lt;- rnorm(100, mean = 0, sd = 0.25)
data &lt;- data.frame(&quot;id&quot; = 1, &quot;x1&quot; = x1, &quot;z1&quot; = z1)

# Matrix linear predictor
Z &lt;- mc_dglm(~ z1, id = &#39;id&#39;, data = data)

# Covariance model
Sigma &lt;- mcglm::mc_matrix_linear_predictor(tau = c(0.2, 0.15), Z = Z)

# Simulating the response variable
y1 &lt;- rnorm(100, mu1$mu, sd = sqrt(diag(Sigma)))
data$y &lt;- y1

# Fitting
fit2.id &lt;- mcglm(linear_pred = c(y1 ~ x1), matrix_pred = list(Z), data = data)
</code></pre>

<pre><code>## Automatic initial values selected.
</code></pre>

<p>We can also extend the linear regression model to deal with longitudinal
data analysis. The code below presents an example of such a model.</p>

<pre><code class="r"># Mean model
x1 &lt;- seq(-1,1, l = 100)
X &lt;- model.matrix(~ x1)
mu1 &lt;- mcglm::mc_link_function(beta = c(1,0.8), X = X, offset = NULL, 
                        link = &quot;identity&quot;)

# Data structure
data &lt;- data.frame(&quot;id&quot; = as.factor(rep(1:10, each = 10)), &quot;x1&quot; = x1)

# Covariance model
Z0 &lt;- mc_id(data)
Z1 &lt;- mc_mixed(~ 0 + id, data = data)
Sigma &lt;- mcglm::mc_matrix_linear_predictor(tau = c(0.2, 0.15), Z = c(Z0,Z1))

# Simulating the Response variable
y1 &lt;- as.numeric(rmvnorm(1, mean = mu1$mu, sigma = as.matrix(Sigma)))
data &lt;- data.frame(&quot;y1&quot; = y1, &quot;x1&quot; = x1)

# Fit
fit3.id &lt;- mcglm(linear_pred = c(y1 ~ x1), 
                 matrix_pred = list(&quot;resp1&quot; = c(Z0,Z1)), data = data)
</code></pre>

<pre><code>## Automatic initial values selected.
</code></pre>

<p>The model summary</p>

<pre><code class="r">summary(fit3.id)
</code></pre>

<pre><code>## Call: y1 ~ x1
## 
## Link function: identity
## Variance function: constant
## Covariance function: identity
## Regression:
##             Estimates  Std.error   Z value     Pr(&gt;|z|)
## (Intercept) 0.8547952 0.05768440 14.818482 1.112705e-49
## x1          0.6100739 0.09849275  6.194099 5.861920e-10
## 
## Dispersion:
##   Estimates  Std.error  Z value     Pr(&gt;|z|)
## 1 0.1775319 0.02291873 7.746151 9.471961e-15
## 2 0.0155217 0.01511449 1.026942 3.044476e-01
## 
## Algorithm: chaser
## Correction: TRUE
## Number iterations: 5
</code></pre>

<p>Note that, the dispersion structure now has two parameters. 
In that case, the parameter \(\tau_1\) represents the longitudinal 
structure for which we are assuming a compound symmetry model. This
model is an equivalent to a random intercept model in the context of
Linear Mixed Models (LMMs).</p>

<h2>Regression models for binomial and bounded data</h2>

<p>The <code>mcglm</code> package offers a rich set of models to deal with binomial
and bounded response variables. The <code>logit</code>, <code>probit</code>, <code>cauchit</code>,
<code>cloglog</code>, and <code>loglog</code> link functions along with the extended binomial
variance function combined with the linear covariance structure, 
provide a flexible class of models for handling binomial and 
bounded response variables. The extended binomial variance function is
given by \(\mu^p (1- \mu)^q\) where the two extra power parameters 
offer more flexibility to model the relationship between mean and 
variance. Consider the following simulated dataset.</p>

<pre><code class="r"># Mean model
x1 &lt;- seq(-1,1, l = 500)
X &lt;- model.matrix(~ x1)
mu1 &lt;- mcglm::mc_link_function(beta = c(1,0.8), X = X, offset = NULL, link = &quot;logit&quot;)

# Data structure
data &lt;- data.frame(&quot;x1&quot; = x1)

# Covariance model
Z0 &lt;- mc_id(data)

# Simulating the response variable
set.seed(123)
data$y &lt;- rbinom(500, prob = mu1$mu, size = 10)/10
</code></pre>

<p>The most traditional regression model to deal with binomial data is the
logistic regression model that can be fitted using the <code>mcglm</code> package
using the following code:</p>

<pre><code class="r"># Fit
fit4.logit &lt;- mcglm(linear_pred = c(y ~ x1), 
                    matrix_pred = list(Z0),
                    link = &quot;logit&quot;, variance = &quot;binomialP&quot;,
                    power_fixed = TRUE,
                    Ntrial = list(rep(10,500)), data = data)
</code></pre>

<pre><code>## Automatic initial values selected.
</code></pre>

<p>It is important to highlight that the response variable collumn should
be between \(0\) and \(1\) and in the case of more than one trial the 
argument <code>Ntrial</code> should be used for fitting the model. 
The argument <code>link</code> specifies the link function whereas the argument 
<code>variance</code> specifies the variance function in that case <code>binomialP</code>. 
The variance function <code>binomialP</code> represents a simplification of the 
extended binomial variance function given by \(\mu^p (1- \mu)^p\). 
Note that, in this example the argument &#39;power_fixed = TRUE&#39; specifies
that the power parameter \(p\) will not be estimated, but fixed at the 
initial value \(p = 1\) corresponding to the orthodox binomial variance
function. 
We can easily fit the model using a different link function, for example
the <code>cauchit</code>.</p>

<pre><code class="r">fit4.cauchit &lt;- mcglm(linear_pred = c(y ~ x1), 
                      matrix_pred = list(Z0),
                      link = &quot;cauchit&quot;, variance = &quot;binomialP&quot;, 
                      Ntrial = list(rep(10,250)), data = data)
</code></pre>

<pre><code>## Automatic initial values selected.
</code></pre>

<p>We can also estimate the extra power parameter \(p\).</p>

<pre><code class="r">fit4.logitP &lt;- mcglm(linear_pred = c(y ~ x1), 
                      matrix_pred = list(Z0),
                      link = &quot;logit&quot;, variance = &quot;binomialP&quot;,
                      power_fixed = FALSE,
                      Ntrial = list(rep(10,500)), data = data)
</code></pre>

<pre><code>## Automatic initial values selected.
</code></pre>

<p>Furthermore, we can estimate the two extra power parameters involved in
the extended binomial variance function.</p>

<pre><code class="r">fit4.logitPQ &lt;- mcglm(linear_pred = c(y ~ x1), 
                      matrix_pred = list(Z0),
                      link = &quot;logit&quot;, variance = &quot;binomialPQ&quot;,
                      power_fixed = FALSE,
                      Ntrial = list(rep(10,500)), 
                      control_algorithm = list(tuning = 0.5, max_iter = 100),
                      data = data)
</code></pre>

<pre><code>## Automatic initial values selected.
</code></pre>

<p>The estimation of the extra power parameters involved in the
extended binomial variance function is challenging mainly for small data 
sets. Note that, in this simulated example, we have to control the 
step-length of the <code>chaser</code> algorithm to avoid unrealistic values for
the parameters involved in the dispersion structure. To do that, we used
the extra argument <code>control_algorithm</code> that should be a named list. 
For a detailed description of the arguments that can be passed to the
<code>control_algorithm</code> function see <code>?fit_mcglm</code>. </p>

<h2>Regression models for count data</h2>

<p>The analysis of count data in the <code>mcglm</code> package relies on the 
structure of the Poisson-Tweedie distribution. Such a distribution is
characterized by the following dispersion function:</p>

<p>\[ \nu(\mu, p) = \mu + \tau_0 \mu^p. \]
The power parameter is an index that identify different distributions,
examples include the Hermite (\(p = 0\)), Neyman-Type A (\(p = 1\)) and the
negative binomial (\(p = 2\)). </p>

<p>The orthodox Poisson model can be fitted using the <code>mcglm</code> package using
the <code>Tweedie</code> variance function \(\nu(\mu, p ) = \mu^p\) where the power
parameter \(p\) is fixed at \(1\). For example,</p>

<pre><code class="r"># Mean model

x1 &lt;- seq(-2,2, l = 200)
X &lt;- model.matrix(~ x1)
mu &lt;- mcglm::mc_link_function(beta = c(1,0.8), X = X, offset = NULL, link = &quot;log&quot;)

# Data structure
data &lt;- data.frame(&quot;x1&quot; = x1)

# Covariance model
Z0 &lt;- mc_id(data)

# Data structure
data$y &lt;- rpois(200, lambda = mu$mu)

# Fit
fit.poisson &lt;- mcglm(linear_pred = c(y ~ x1), 
                    matrix_pred = list(Z0),
                    link = &quot;log&quot;, variance = &quot;tweedie&quot;,
                    power_fixed = TRUE, data = data)
</code></pre>

<pre><code>## Automatic initial values selected.
</code></pre>

<p>Another very useful model for count data is the negative binomial. </p>

<pre><code class="r"># Simulating negative binomial models
set.seed(1811)
x &lt;- rtweedie(200, mu = mu$mu, power = 2, phi = 0.5)
y &lt;- rpois(200, lambda = x)
data &lt;- data.frame(&quot;y1&quot; = y, &quot;x1&quot; = x1)

fit.pt &lt;- mcglm(linear_pred = c(y ~ x1), matrix_pred = list(Z0), 
                link = &quot;log&quot;, variance = &quot;poisson_tweedie&quot;, 
                power_fixed = FALSE, data = data)
</code></pre>

<pre><code>## Automatic initial values selected.
</code></pre>

<pre><code class="r">summary(fit.pt)
</code></pre>

<pre><code>## Call: y ~ x1
## 
## Link function: log
## Variance function: poisson_tweedie
## Covariance function: identity
## Regression:
##             Estimates  Std.error  Z value     Pr(&gt;|z|)
## (Intercept) 0.8551973 0.07095214 12.05316 1.866611e-33
## x1          0.9285076 0.06336780 14.65267 1.295191e-48
## 
## Power:
##   Estimates Std.error Z value     Pr(&gt;|z|)
## 1  2.233986 0.3291973 6.78616 1.151575e-11
## 
## Dispersion:
##   Estimates Std.error  Z value  Pr(&gt;|z|)
## 1 0.2827984 0.1906259 1.483525 0.1379349
## 
## Algorithm: chaser
## Correction: TRUE
## Number iterations: 9
</code></pre>

<p>Note that, we estimate the power parameter rather than fix it at \(p = 2\).</p>

<!---------------------------------------------------------------------- -->

</body>

</html>
